// A test program in Cone that does nothing interesting

mod submod
  include std
  mut r = 9
  fn incr()
    r=inc(r)

extern
  fn print(str *u8)

mut glowy = 34u32
mut glo2 i32 = 7

struct refstruct {ref &rc mut u32;}
fn rcmret() u32, &rc mut u32
  24, &rc mut 32
fn rcstruct()
  mut str refstruct
  mut s &own u32
  rcmret()
  str.ref, s = &rc mut 3, &own 2
  imm newstr = &own str
  return

struct Opaque;
imm gloref &?Opaque = null  // nullable reference
fn rcpass(ref &rc mut u32) &rc mut u32
    if ref
        imm x = 3
    ref

fn rcx(ref &rc mut i32) &rc mut i32
    imm rcref &rc mut i32 = if (*ref == 10) {ref;} else {&rc mut 16;};
    rcref

fn rctest()
    mut rcref = &rc mut 32u32
    mut r2 = rcref
    rcref = r2 = rcx(r2)
    rcpass(rcref)
    mut rcref2 = &rc mut 4u32
    rcref2 = rcref
    *rcref = *rcref + 1
  
fn cone() u32
    submod::incr()
    rctest()
    print("hello")
    points()
    mut unsy = 23
    imm calcptr = &calc
    // imm anonfn = &fn (x i32) i32 {x*x;}
    // (*anonfn)(3)
    '\t'
    2.3e1
    glowy = unsy
    glo2 = glowy // cast
    glowy // Implicit return of global var's value
    bitfn(0x1a, 0x42)
    (*calcptr)(&mut unsy, 3) // Forward reference call
    array(2)
    mut z1 i32; mut z2 i32; z1,z2=swap(-2, 5)
    fact(6)

// Structure handling test
struct Point
    x f32
    y f32
    _z f32
    fn add(self &) f32
        x + self.y
    fn add(self) f32
        x + `()`()
    fn add(self, other) f32
        self.x + other.x
    fn `()`() f32
        x - _z
    set fn xset(self &mut, xx f32)
        x = xx

fn points()
    mut pt Point
    mut xpt Point
    xpt.x = 3f
    (&pt).add()
    pt.add()
    pt();
    xpt = pt
    imm rpt = &mut pt
    imm a = rpt.x
    rpt.x = (pt.x).sqrt()

fn bitfn(a u32, b u32) u32
    mut bin = a==0x1a
    bin = b > 100u32
    if a>4
      return b
    (a & bin | a ^ ~b).shl(1)

fn fact(mut nbr u32) u32
  mut result = 1
  while nbr > 1 and !nbr>50
    result = result * nbr
    break if result > 10000u
    nbr = nbr - 1
  result
  // if nbr { nbr*fact(nbr-1); } else { 1; }
  
fn calc(aa &mut i32, b = 1) i32
  imm a = *aa
  *aa = 5
  -a + (a+a)*b % b

fn array(index u32) u8
  mut a [4] u8 = [4u8, 10u8, 12u8, 40u8]
  mut b = a
  mut slice &[]u8 = &b
  imm ptr *u8 = slice
  imm len usize = slice
  b[0] = a[2]
  slice[1] = b[3]
  slice[index]
  
fn swap(mut x i32, mut y i32) i32,i32
  x, y = y, x
  x,y

fn refs()
  mut a = 3
  mut b = &a
  if true
    mut c = 5
    // b = &c  // Uncomment for lifetime error

